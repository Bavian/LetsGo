
# Строки

Язык Go использует UTF-8 для кодировки символов.

Строки являются неизменяемыми.

Любую строку можно описать как структуру из двух элементов. массив `byte` и длины строки `len int`.

Литералы могут быть объявленны двумя способами:

* Интерпретируемые

  ```go
  "Hello,\nWorld!\n"
  ```

  Строка обрабатывает специальные символы. Обычная запись строки. Такой способ будет встречаться чаще всего.

* Необработанные

  ```go
  `Hello,
  World!
  `
  ```

  Строка будет объявлена ровно в том виде, в котором написана. Не подвержена влиянию синтаксиса извне.

В разнице этих записей можно разобраться, если осознать, что в примерах приведены равные строки.

## Базовые операции со строками

### Конкатенация

Строки могут быть сконкатенированы с помощью операторов `+` и `+=`.

```go
var str = "Hello" + ", " + "World"
str += "!"
fmt.Printf(str) // Hello, World!
```

### Сравнение и лексографический порядок

Строки можно сравнивать в лексографическом порядке с помощью операторов `==`, `!=`, `>`, `<`, `>=` и `<=`.
Иными словами, сравнение будет производиться по массивым `byte` этих строк, но, если одна строка является приставкой другого, то строка, являющаяся приставкой, будет меньше.
  
```go
fmt.Printf("Hello" < "Hello, World!") // true
fmt.Printf("Bye, Friend!" > "Hello, World") // false
```

### Длина

Для получения длины строки необходимо вызвать функцию `len`.
```go
fmt.Printf(len("Hello, World!\n")) // 14
```

### Получение символа

Символ из строки можно получить с помощью квадратных скобок и индекса нужного символа внутри них.
Данная операция вернёт `byte`(`int8`).

```go
val str = "Hello, World!"
fmt.Printf("%c", str[7]) // W
```

Так как строки неизменяемые, то запись вида `str[n] = 'G'` приведет к ошибке компиляции.

### Срезы

Подстроку можно получить с помощью срезов(slice).

```go
var str = "Hello, World!";
fmt.Printf(str[7:]) // World!
fmt.Printf(str[:4]) // Hello
fmt.Printf(str[3:4]) // llo
```

